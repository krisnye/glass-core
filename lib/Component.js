// Generated by CoffeeScript 1.6.3
(function() {
  var Component, assert, dispose, exports, extend, generateId, get, getBaseDefiningClass, getUnderrideName, glass, initialize, jsonSchema, properties, serializeProperty, state, underride,
    __slice = [].slice;

  glass = require('./');

  jsonSchema = require('json-schema');

  generateId = function(parent, type) {
    var count, counts, name;
    name = type.name;
    if (name == null) {
      throw new Error("type did not have a name: " + type);
    }
    counts = parent._Component_generateId_counts != null ? parent._Component_generateId_counts : parent._Component_generateId_counts = {};
    count = counts[name] != null ? counts[name] : counts[name] = 0;
    count++;
    counts[name] = count;
    return "" + name + "_" + count;
  };

  module.exports = exports = Component = Component = (function() {
    function Component(properties) {
      this.initialize(properties);
      this;
    }

    return Component;

  })();

  serializeProperty = function(object, name, property) {
    var _ref;
    if (property == null) {
      property = (_ref = object.constructor.properties) != null ? _ref[name] : void 0;
    }
    if ((property != null ? property.serialize : void 0) != null) {
      return property.serialize;
    }
    if ((property != null ? property.get : void 0) != null) {
      return false;
    }
    if (name[0] === '_') {
      return false;
    }
    return object.hasOwnProperty(name);
  };

  glass.defineProperties(Component, {
    isComponentType: function(type) {
      return (type != null) && (type.id != null) && (type.properties != null) && (type.extend != null);
    },
    id: module.id,
    toString: function() {
      return this.id;
    },
    valueOf: function() {
      var _ref;
      return (_ref = this.value) != null ? _ref : this.id;
    },
    disposeProperties: function(object) {
      var key, value;
      for (key in object) {
        value = object[key];
        if ((value != null) && value.parent === object && Object.isFunction(value.dispose)) {
          value.dispose();
        }
      }
    },
    fromJSON: function(values, fromFunction) {
      var children, getComponentType, key, parent, value;
      getComponentType = function(value) {
        var type, typeId;
        typeId = value != null ? value[glass.serialize.typeKey.toString()] : void 0;
        if ((typeId != null) && Component.isComponentType(type = require(typeId))) {
          return type;
        }
        return null;
      };
      children = null;
      for (key in values) {
        value = values[key];
        if (getComponentType(value) != null) {
          if (children == null) {
            children = {};
          }
          children[key] = value;
          delete values[key];
        } else {
          values[key] = fromFunction(value);
        }
      }
      parent = new this(values);
      if (children != null) {
        for (key in children) {
          value = children[key];
          value.id = key;
          value.parent = parent;
          fromFunction(value);
        }
      }
      return parent;
    },
    extend: function(subClassDefinition) {
      return extend(this, subClassDefinition);
    }
  }, {
    enumerable: true
  });

  state = {
    constructed: 0,
    initializing: 1,
    initialized: 2,
    disposing: 3,
    disposed: 4
  };

  properties = {
    id: {
      get: function() {
        return this._id;
      },
      set: function(value) {
        if (this._state === state.constructed) {
          this._id = value;
        }
        return value;
      },
      serialize: true,
      unique: true
    },
    parent: {
      get: function() {
        return this._parent;
      },
      set: function(value) {
        if (this._state === state.constructed) {
          this._parent = value;
        }
        return value;
      },
      serialize: false
    },
    inner: {
      description: "Calls the subclass defined function if present.",
      value: function() {
        var args, fn, innerName, _ref;
        fn = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
        innerName = fn.innerName != null ? fn.innerName : fn.innerName = getUnderrideName(fn.definingClass, fn.id);
        return (_ref = this[innerName]) != null ? _ref.apply(this, args) : void 0;
      }
    },
    _state: {
      value: state.constructed,
      serialize: false
    },
    serialize: {
      value: true,
      serialize: false
    },
    initialize: initialize = function(properties) {
      var id, key, parent, value, _ref;
      if (properties != null) {
        parent = properties.parent;
        if (parent != null) {
          id = properties.id != null ? properties.id : properties.id = generateId(parent, this.constructor);
          parent[id] = this;
        }
        for (key in properties) {
          value = properties[key];
          this[key] = value;
        }
      }
      if (((_ref = this.parent) != null ? _ref._state : void 0) === state.initializing) {
        this.serialize = false;
      }
      this._state = state.initializing;
      this.inner(initialize);
      return this._state = state.initialized;
    },
    dispose: dispose = function() {
      if (this._state < state.disposing) {
        this._state = state.disposing;
        Component.disposeProperties(this);
        if (this._parent != null) {
          delete this._parent[this.id];
        }
        this.inner(dispose);
        this._state = state.disposed;
      }
    },
    disposed: {
      get: function() {
        return this._state >= state.disposed;
      },
      serialize: false
    },
    toJSON: function() {
      var name, property, value, values, _ref;
      values = {};
      values[glass.serialize.typeKey.toString()] = this.constructor.id;
      _ref = this.constructor.properties;
      for (name in _ref) {
        property = _ref[name];
        if (serializeProperty(this, name, property)) {
          value = this[name];
          if ((value != null ? value.serialize : void 0) !== false) {
            if ((value != null ? value.toJSON : void 0) != null) {
              value = value.toJSON();
            }
            values[name] = value;
          }
        }
      }
      for (name in this) {
        value = this[name];
        if (!values.hasOwnProperty(name)) {
          if (serializeProperty(this, name)) {
            if ((value != null ? value.serialize : void 0) !== false) {
              if ((value != null ? value.toJSON : void 0) != null) {
                value = value.toJSON();
              }
              values[name] = value;
            }
          }
        }
      }
      return values;
    },
    get: get = function(id, parsed) {
      var colon, factory, isClass, throwError, type, value, _ref;
      if (id == null) {
        throw new Error("id is required");
      }
      value = this.inner(get, id, parsed);
      if (value !== void 0) {
        return value;
      }
      value = this[id];
      if (value != null) {
        if (value.disposed === true) {
          value = null;
        } else {
          return value;
        }
      }
      throwError = parsed == null;
      if (parsed == null) {
        colon = id.indexOf(':');
        if (colon > 0) {
          parsed = {
            type: id.substring(0, colon),
            properties: JSON.parse(id.substring(colon + 1))
          };
        } else {
          parsed = false;
        }
      }
      if (parsed) {
        type = parsed.type;
        properties = parsed.properties;
        factory = this[type];
        if (Object.isFunction(factory)) {
          properties.parent = this;
          isClass = factory.properties != null;
          if (isClass) {
            value = new factory(properties);
          } else {
            value = factory(properties);
          }
        }
      }
      if (value == null) {
        value = (_ref = this._parent) != null ? typeof _ref.get === "function" ? _ref.get(id, parsed) : void 0 : void 0;
      }
      if (value != null) {
        this[id] = value;
      } else if (throwError) {
        throw new Error("Component not found: " + id);
      }
      return value;
    },
    constrain: function() {},
    validate: function() {
      var result;
      result = jsonSchema.validate(this, this.constructor);
      if (result.valid) {
        return null;
      } else {
        return result.errors;
      }
    }
  };

  Component.properties = glass.defineProperties(Component.prototype, properties, Component);

  getUnderrideName = function(baseDefiningClass, name) {
    return "" + baseDefiningClass.name + "_subclass_" + name;
  };

  getBaseDefiningClass = function(classDefinition, properties, name) {
    var baseDefiningClass, baseFunction, baseProperty, callsUnderride, underrideName, underrideProperty;
    baseProperty = properties[name];
    while (true) {
      baseFunction = baseProperty.value;
      baseDefiningClass = baseProperty.definingClass;
      underrideName = getUnderrideName(baseDefiningClass, name);
      callsUnderride = baseFunction.toString().has(underrideName) || baseFunction.toString().has(/\binner\b/);
      if (!callsUnderride) {
        throw new Error("" + classDefinition.name + "." + name + " cannot be defined because " + baseDefiningClass.name + "." + name + " does not call " + underrideName + ".");
      }
      underrideProperty = properties[underrideName];
      if (underrideProperty != null) {
        baseProperty = underrideProperty;
      } else {
        return baseDefiningClass;
      }
    }
  };

  underride = function(classDefinition, properties, rootDefiningClass, name, fn) {
    var baseDefiningClass;
    baseDefiningClass = getBaseDefiningClass(classDefinition, properties, name);
    properties[getUnderrideName(baseDefiningClass, name)] = fn;
  };

  extend = function(baseClass, subClassDefinition) {
    var baseProperty, name, property, prototype, subClass, subProperties, _i, _len, _ref, _ref1, _ref2;
    if (subClassDefinition.name == null) {
      subClassDefinition.name = (_ref = subClassDefinition.id) != null ? (_ref1 = _ref.match(/([a-z_0-9\$]+)(\.js)?$/i)) != null ? _ref1[1] : void 0 : void 0;
    }
    if (!Object.isString(subClassDefinition.name)) {
      throw new Error("missing name property");
    }
    subClass = eval("(function " + subClassDefinition.name + "(properties) {\n    this.initialize(properties);\n})");
    subProperties = subClassDefinition.properties = glass.normalizeProperties(subClassDefinition.properties, subClass);
    prototype = subClass.prototype;
    properties = Object.clone(baseClass.properties);
    for (name in subProperties) {
      property = subProperties[name];
      baseProperty = properties[name];
      if (Object.isFunction(baseProperty != null ? baseProperty.value : void 0) && baseProperty.override !== true) {
        if (!Object.isFunction(property.value)) {
          throw new Error("Functions can only be overridden with other functions: " + property.value);
        }
        underride(subClassDefinition, properties, baseProperty.definingClass, name, property.value);
      } else {
        properties[name] = property;
      }
    }
    subClassDefinition.properties = properties;
    _ref2 = ["extend", "fromJSON", "toString", "valueOf"];
    for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
      name = _ref2[_i];
      subClass[name] = Component[name];
    }
    Object.merge(subClass, subClassDefinition, false, false);
    glass.defineProperties(prototype, properties, subClass);
    return subClass;
  };

  assert = require('chai').assert;

  exports.test = {
    "should have an id": function() {
      return assert(Object.isString(Component.id));
    },
    "its toString should return it's id": function() {
      return assert.equal(Component.toString(), Component.id);
    },
    "should have a name": function() {
      return assert.equal(Component.name, "Component");
    },
    '#dispose': {
      'should mark self disposed': function() {
        var a;
        a = new Component;
        a.dispose();
        return assert(a.disposed);
      },
      'should dispose of children': function() {
        var a, b;
        a = new Component;
        b = new Component({
          parent: a
        });
        a.dispose();
        return assert(b.disposed);
      },
      'should remove property from parent': function() {
        var a, parent;
        parent = {};
        a = new Component({
          parent: parent
        });
        a.dispose();
        return assert(parent[a.id] == null);
      }
    },
    '#Constructor': {
      'should set itself as property on parent': function() {
        var a, parent;
        parent = {};
        a = new Component({
          parent: parent
        });
        assert(Object.isString(a.id));
        assert.equal(parent[a.id], a);
        return a.dispose();
      },
      'should not let late parent assignment': function() {
        var a;
        a = new Component;
        a.parent = {};
        return assert(a.parent == null);
      },
      'should generate a missing id if it has a parent': function() {
        var a, parent;
        parent = {};
        a = new Component({
          parent: parent
        });
        assert(Object.isString(a.id));
        return a.dispose();
      }
    },
    "#get": {
      'should throw exception if instance not found': function() {
        var a;
        a = new Component;
        assert.throws(function() {
          return a.get("foo");
        });
        return a.dispose();
      },
      'should create instances with factory': function() {
        var SubComponent, a, b, c;
        SubComponent = Component.extend({
          id: 'SubComponent'
        });
        a = new Component;
        b = new Component({
          parent: a
        });
        a[SubComponent] = SubComponent;
        c = b.get('SubComponent:{"x":2,"y":3}');
        assert.equal(c.x, 2);
        assert.equal(c.y, 3);
        assert.equal(c.parent, a);
        return a.dispose();
      }
    },
    'serialize': function() {
      var SubComponent, p, result, s, serialized, _ref, _ref1;
      SubComponent = Component.extend({
        id: module.id,
        properties: {
          initialize: function() {
            return new Component({
              id: 'a',
              parent: this
            });
          }
        }
      });
      s = new SubComponent();
      p = new Component({
        parent: s,
        foo: 2
      });
      assert.equal(s.serialize, true);
      assert(s.a != null, 'child component a exists.');
      assert.equal(s.a.serialize, false);
      serialized = glass.serialize(s);
      result = glass.deserialize(serialized);
      assert.equal((_ref = result.Component_1) != null ? _ref.parent : void 0, result);
      assert.equal((_ref1 = result.Component_1) != null ? _ref1.foo : void 0, 2);
      return assert.equal(serialized, glass.serialize(result));
    },
    'extend': {
      'should inherit instance properties': function() {
        var SubComponent;
        SubComponent = Component.extend({
          name: 'SubComponent'
        });
        return assert(SubComponent.properties.id != null);
      },
      'should define static properties': function() {
        var SubComponent;
        SubComponent = Component.extend({
          name: 'SubComponent',
          staticValue: 2
        });
        return assert.equal(SubComponent.staticValue, 2);
      },
      'should allow underriding constructors and functions': function() {
        var SubComponent, sub;
        SubComponent = Component.extend({
          name: 'SubComponent',
          properties: {
            initialize: function() {
              this.constructorCalled = true;
              return this;
            },
            dispose: function() {
              this.disposeCalled = true;
            }
          }
        });
        sub = new SubComponent;
        assert(sub.constructorCalled);
        sub.dispose();
        assert(sub.disposed);
        return assert(sub.disposeCalled);
      },
      'should allow recursive extension': function() {
        var AComponent, BComponent;
        AComponent = Component.extend({
          name: 'AComponent',
          properties: {
            dispose: function() {}
          }
        });
        BComponent = AComponent.extend({
          name: 'BComponent',
          properties: {
            foo: function() {}
          }
        });
      },
      'should not allow final functions to be underridden': function() {
        var AComponent;
        AComponent = Component.extend({
          name: 'AComponent',
          properties: {
            dispose: function() {}
          }
        });
        return assert.throws(function() {
          var BComponent;
          return BComponent = AComponent.extend({
            name: 'BComponent',
            properties: {
              dispose: function() {}
            }
          });
        });
      }
    },
    'validation': {
      'should work': function() {
        var Person, errors, invalid, valid;
        Person = Component.extend({
          name: 'SubComponent',
          properties: {
            name: {
              type: 'string',
              required: true,
              minLength: 2,
              maxLength: 100
            },
            age: {
              type: 'integer',
              minimum: 0,
              maximum: 130
            },
            key: {
              type: 'string'
            }
          }
        });
        invalid = new Person({
          name: "a",
          age: -2
        });
        errors = invalid.validate();
        assert((errors != null ? errors.length : void 0) === 2, JSON.stringify(errors));
        valid = new Person({
          name: "good",
          age: 112
        });
        errors = valid.validate();
        if ((errors != null ? errors.length : void 0) > 0) {
          console.log(JSON.stringify(errors));
        }
        return assert(errors == null);
      }
    }
  };

}).call(this);
