// Generated by CoffeeScript 1.6.3
(function() {
  var Component, assert, dispose, exports, extend, generateId, getBaseDefiningClass, getUnderrideName, glass_Component, initialize, isPrimitive, jsonSchema, properties, state, underride,
    __slice = [].slice;

  require('./global');

  jsonSchema = require('json-schema');

  generateId = function(parent, type) {
    var count, counts, name;
    name = type.name;
    if (name == null) {
      throw new Error("type did not have a name: " + type);
    }
    counts = parent._Component_generateId_counts != null ? parent._Component_generateId_counts : parent._Component_generateId_counts = {};
    count = counts[name] != null ? counts[name] : counts[name] = 0;
    count++;
    counts[name] = count;
    return "" + name + "_" + count;
  };

  module.exports = exports = Component = glass_Component = (function() {
    function glass_Component(properties) {
      this.initialize(properties);
      this;
    }

    return glass_Component;

  })();

  isPrimitive = function(object) {
    return Object.isNumber(object) || Object.isBoolean(object) || Object.isString(object);
  };

  Component.normalizeProperties = function(properties, definingClass) {
    var name, property, _base, _base1;
    if (properties == null) {
      properties = {};
    }
    for (name in properties) {
      property = properties[name];
      if (Object.isFunction(property)) {
        property = {
          writable: false,
          value: property
        };
      } else if ((property == null) || isPrimitive(property) || Object.isArray(property)) {
        property = {
          value: property
        };
      }
      if ((property.get == null) && (property.set == null) && !property.hasOwnProperty('value')) {
        property.value = void 0;
      }
      if (property.hasOwnProperty('value')) {
        if (property.writable == null) {
          property.writable = true;
        }
      }
      if (Object.isFunction(property.value)) {
        if ((_base = property.value).id == null) {
          _base.id = name;
        }
      }
      if (definingClass != null) {
        if (property.definingClass == null) {
          property.definingClass = definingClass;
        }
        if (Object.isFunction(property.value)) {
          if ((_base1 = property.value).definingClass == null) {
            _base1.definingClass = definingClass;
          }
        }
      }
      properties[name] = property;
    }
    return properties;
  };

  Component.defineProperties = function(object, properties, definingClass) {
    properties = Component.normalizeProperties(properties, definingClass);
    Object.defineProperties(object, properties);
    return properties;
  };

  Component.disposeProperties = function(object) {
    var key, value;
    for (key in object) {
      value = object[key];
      if ((value != null) && value.parent === object && Object.isFunction(value.dispose)) {
        value.dispose();
      }
    }
  };

  Component.id = "glass.Component";

  Component.toString = function() {
    return this.id;
  };

  Component.valueOf = function() {
    var _ref;
    return (_ref = this.value) != null ? _ref : this.id;
  };

  state = {
    constructed: 0,
    initializing: 1,
    initialized: 2,
    disposing: 3,
    disposed: 4
  };

  properties = {
    id: {
      get: function() {
        return this._id;
      },
      set: function(value) {
        if (this._state > state.constructed) {
          throw new Error("id can only be specified in constructor");
        }
        return this._id = value;
      },
      unique: true
    },
    parent: {
      get: function() {
        return this._parent;
      },
      set: function(value) {
        if (this._state > state.constructed) {
          throw new Error("parent can only be specified in constructor");
        }
        return this._parent = value;
      },
      persist: false
    },
    inner: {
      description: "Calls the subclass defined function if present.",
      value: function() {
        var args, fn, innerName, _ref;
        fn = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
        innerName = fn.innerName != null ? fn.innerName : fn.innerName = getUnderrideName(fn.definingClass, fn.id);
        return (_ref = this[innerName]) != null ? _ref.apply(this, args) : void 0;
      }
    },
    _state: {
      value: state.constructed,
      persist: false
    },
    initialize: initialize = function(properties) {
      var id, key, parent, value;
      if (properties != null) {
        parent = properties.parent;
        if (parent != null) {
          id = properties.id != null ? properties.id : properties.id = generateId(parent, this.constructor);
          parent[id] = this;
        }
        for (key in properties) {
          value = properties[key];
          this[key] = value;
        }
      }
      this._state = state.initializing;
      this.inner(initialize);
      return this._state = state.initialized;
    },
    dispose: dispose = function() {
      if (this._state < state.disposing) {
        this._state = state.disposing;
        Component.disposeProperties(this);
        if (this._parent != null) {
          delete this._parent[this.id];
        }
        this.inner(dispose);
        this._state = state.disposed;
      }
    },
    disposed: {
      get: function() {
        return this._state >= state.disposed;
      },
      persist: false
    },
    toJSON: function() {
      var name, property, value, values, _ref;
      values = {};
      _ref = this.constructor.properties;
      for (name in _ref) {
        property = _ref[name];
        if (property.persist !== false && ((property.get != null) || this.hasOwnProperty(name))) {
          value = this[name];
          if ((value != null ? value.toJSON : void 0) != null) {
            value = value.toJSON();
          }
          values[name] = value;
        }
      }
      return values;
    },
    get: function(id, parsed) {
      var colon, factory, isClass, throwError, type, value, _ref;
      if (id == null) {
        throw new Error("id is required");
      }
      value = this[id];
      if (value != null) {
        if (value.disposed === true) {
          value = null;
        } else {
          return value;
        }
      }
      throwError = parsed == null;
      if (parsed == null) {
        colon = id.indexOf(':');
        if (colon > 0) {
          parsed = {
            type: id.substring(0, colon),
            properties: JSON.parse(id.substring(colon + 1))
          };
        } else {
          parsed = false;
        }
      }
      if (parsed) {
        type = parsed.type;
        properties = parsed.properties;
        factory = this[type];
        if (Object.isFunction(factory)) {
          properties.parent = this;
          isClass = factory.properties != null;
          if (isClass) {
            value = new factory(properties);
          } else {
            value = factory(properties);
          }
        }
      }
      if (value == null) {
        value = (_ref = this._parent) != null ? typeof _ref.get === "function" ? _ref.get(id, parsed) : void 0 : void 0;
      }
      if (value != null) {
        this[id] = value;
      } else if (throwError) {
        throw new Error("Component not found: " + id);
      }
      return value;
    },
    constrain: function() {},
    validate: function() {
      var result;
      result = jsonSchema.validate(this, this.constructor);
      if (result.valid) {
        return null;
      } else {
        return result.errors;
      }
    }
  };

  Component.properties = Component.defineProperties(Component.prototype, properties, Component);

  getUnderrideName = function(baseDefiningClass, name) {
    return "" + baseDefiningClass.name + "_subclass_" + name;
  };

  getBaseDefiningClass = function(classDefinition, properties, name) {
    var baseDefiningClass, baseFunction, baseProperty, callsUnderride, underrideName, underrideProperty;
    baseProperty = properties[name];
    while (true) {
      baseFunction = baseProperty.value;
      baseDefiningClass = baseProperty.definingClass;
      underrideName = getUnderrideName(baseDefiningClass, name);
      callsUnderride = baseFunction.toString().has(underrideName) || baseFunction.toString().has(/\binner\b/);
      if (!callsUnderride) {
        throw new Error("" + classDefinition.name + "." + name + " cannot be defined because " + baseDefiningClass.name + "." + name + " does not call " + underrideName + ".");
      }
      underrideProperty = properties[underrideName];
      if (underrideProperty != null) {
        baseProperty = underrideProperty;
      } else {
        return baseDefiningClass;
      }
    }
  };

  underride = function(classDefinition, properties, rootDefiningClass, name, fn) {
    var baseDefiningClass;
    baseDefiningClass = getBaseDefiningClass(classDefinition, properties, name);
    properties[getUnderrideName(baseDefiningClass, name)] = fn;
  };

  extend = function(baseClass, subClassDefinition) {
    var baseProperty, name, property, prototype, subClass, subProperties;
    if (!Object.isString(subClassDefinition != null ? subClassDefinition.id : void 0)) {
      throw new Error("missing id property");
    }
    subClassDefinition.name = subClassDefinition.id.replace(/[\.\/]/g, '_');
    subClass = eval("(function " + subClassDefinition.name + "(properties) {\n    this.initialize(properties);\n})");
    subProperties = subClassDefinition.properties = Component.normalizeProperties(subClassDefinition.properties, subClass);
    prototype = subClass.prototype;
    properties = Object.clone(baseClass.properties);
    for (name in subProperties) {
      property = subProperties[name];
      baseProperty = properties[name];
      if (Object.isFunction(baseProperty != null ? baseProperty.value : void 0)) {
        if (!Object.isFunction(property.value)) {
          throw new Error("Functions can only be overridden with other functions: " + property.value);
        }
        underride(subClassDefinition, properties, baseProperty.definingClass, name, property.value);
      } else {
        properties[name] = property;
      }
    }
    subClassDefinition.properties = properties;
    Object.merge(subClass, subClassDefinition);
    Component.defineProperties(prototype, properties, subClass);
    subClass.extend = function(subClassDefinition) {
      return extend(subClass, subClassDefinition);
    };
    return subClass;
  };

  Component.extend = function(subClassDefinition) {
    return extend(Component, subClassDefinition);
  };

  assert = require('chai').assert;

  exports.test = {
    "should have an id": function() {
      return assert(Object.isString(Component.id));
    },
    "its toString should return it's id": function() {
      return assert.equal(Component.toString(), "glass.Component");
    },
    "should have a name": function() {
      return assert.equal(Component.name, "glass_Component");
    },
    '#dispose': {
      'should mark self disposed': function() {
        var a;
        a = new Component;
        a.dispose();
        return assert(a.disposed);
      },
      'should dispose of children': function() {
        var a, b;
        a = new Component;
        b = new Component({
          parent: a
        });
        a.dispose();
        return assert(b.disposed);
      },
      'should remove property from parent': function() {
        var a, parent;
        parent = {};
        a = new Component({
          parent: parent
        });
        a.dispose();
        return assert(parent[a.id] == null);
      }
    },
    '#defineProperties': {
      "should allow primitive values": function() {
        var object;
        object = {};
        Component.defineProperties(object, {
          f: function() {
            return "function";
          },
          i: 2,
          b: true,
          a: [],
          s: "hello"
        });
        assert(Object.isFunction(object.f));
        assert.equal(object.f(), "function");
        assert.equal(object.i, 2);
        assert.equal(object.b, true);
        assert(Object.equal(object.a, []));
        return assert.equal(object.s, "hello");
      }
    },
    '#Constructor': {
      'should set itself as property on parent': function() {
        var a, parent;
        parent = {};
        a = new Component({
          parent: parent
        });
        assert(Object.isString(a.id));
        assert.equal(parent[a.id], a);
        return a.dispose();
      },
      'should not let late parent assignment': function() {
        return assert.throws(function() {
          var a;
          a = new Component;
          return a.parent = {};
        });
      },
      'should generate a missing id if it has a parent': function() {
        var a, parent;
        parent = {};
        a = new Component({
          parent: parent
        });
        assert(Object.isString(a.id));
        return a.dispose();
      }
    },
    "#get": {
      'should throw exception if instance not found': function() {
        var a;
        a = new Component;
        assert.throws(function() {
          return a.get("foo");
        });
        return a.dispose();
      },
      'should create instances with factory': function() {
        var a, b, c;
        a = new Component;
        b = new Component({
          parent: a
        });
        a[Component] = Component;
        c = b.get('glass.Component:{"x":2,"y":3}');
        assert.equal(c.x, 2);
        assert.equal(c.y, 3);
        assert.equal(c.parent, a);
        return a.dispose();
      }
    },
    'extend': {
      'should inherit instance properties': function() {
        var SubComponent;
        SubComponent = Component.extend({
          id: 'SubComponent'
        });
        return assert(SubComponent.properties.id != null);
      },
      'should define static properties': function() {
        var SubComponent;
        SubComponent = Component.extend({
          id: 'SubComponent',
          staticValue: 2
        });
        return assert.equal(SubComponent.staticValue, 2);
      },
      'should allow underriding constructors and functions': function() {
        var SubComponent, sub;
        SubComponent = Component.extend({
          id: 'SubComponent',
          properties: {
            initialize: function() {
              this.constructorCalled = true;
              return this;
            },
            dispose: function() {
              this.disposeCalled = true;
            }
          }
        });
        sub = new SubComponent;
        assert(sub.constructorCalled);
        sub.dispose();
        assert(sub.disposed);
        return assert(sub.disposeCalled);
      },
      'should allow recursive extension': function() {
        var AComponent, BComponent;
        AComponent = Component.extend({
          id: 'AComponent',
          properties: {
            dispose: function() {}
          }
        });
        BComponent = AComponent.extend({
          id: 'BComponent',
          properties: {
            foo: function() {}
          }
        });
      },
      'should not allow final functions to be underridden': function() {
        var AComponent;
        AComponent = Component.extend({
          id: 'AComponent',
          properties: {
            dispose: function() {}
          }
        });
        return assert.throws(function() {
          var BComponent;
          return BComponent = AComponent.extend({
            id: 'BComponent',
            properties: {
              dispose: function() {}
            }
          });
        });
      }
    },
    'validation': {
      'should work': function() {
        var Person, errors, invalid, valid;
        Person = Component.extend({
          id: 'SubComponent',
          properties: {
            name: {
              type: 'string',
              required: true,
              minLength: 2,
              maxLength: 100
            },
            age: {
              type: 'integer',
              minimum: 0,
              maximum: 130
            },
            key: {
              type: 'string'
            }
          }
        });
        invalid = new Person({
          name: "a",
          age: -2
        });
        errors = invalid.validate();
        assert((errors != null ? errors.length : void 0) === 2, JSON.stringify(errors));
        valid = new Person({
          name: "good",
          age: 112
        });
        errors = valid.validate();
        if ((errors != null ? errors.length : void 0) > 0) {
          console.log(JSON.stringify(errors));
        }
        return assert(errors == null);
      }
    }
  };

}).call(this);

/*
//@ sourceMappingURL=Component.map
*/
